name: Release
on:
  push:
    tags: [ 'v*' ]
  workflow_dispatch:

permissions:
  contents: write
  packages: write
  deployments: write

jobs:
  release:
    strategy:
      fail-fast: false
      matrix:
        platform: [macos-latest, ubuntu-latest, windows-latest]
        arch: [x64, arm64]
        exclude:
          - platform: macos-latest
            arch: x64
          - platform: macos-latest
            arch: arm64
        include:
          - platform: macos-latest
            arch: universal
    runs-on: ${{ matrix.platform }}
    env:
      TAURI_PRIVATE_KEY: ${{ secrets.TAURI_PRIVATE_KEY }}
      TAURI_KEY_PASSWORD: ${{ secrets.TAURI_KEY_PASSWORD }}
      GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install Rust (Stable)
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.platform == 'windows-latest' && matrix.arch == 'arm64' && 'aarch64-pc-windows-msvc' || matrix.platform == 'macos-latest' && matrix.arch == 'universal' && 'aarch64-apple-darwin x86_64-apple-darwin' || '' }}

      - name: Rust Cache
        uses: Swatinem/rust-cache@v2
        with:
          shared-key: "tauri-build-${{ matrix.platform }}-${{ matrix.arch || 'x64' }}"

      - name: Install Dependencies (ubuntu only)
        if: matrix.platform == 'ubuntu-latest'
        run: |
          sudo apt-get update
          sudo apt-get install -y libgtk-3-dev libwebkit2gtk-4.1-dev libappindicator3-dev librsvg2-dev patchelf libssl-dev

      - name: Install frontend dependencies
        run: npm install

      - name: Install macOS targets
        if: matrix.platform == 'macos-latest'
        run: |
          rustup target add x86_64-apple-darwin aarch64-apple-darwin

      - name: Setup Windows ARM64 environment
        if: matrix.platform == 'windows-latest' && matrix.arch == 'arm64'
        run: |
          echo "RUSTFLAGS=-C target-feature=+crt-static" >> $GITHUB_ENV

      - name: Build the app (Standard x64)
        if: matrix.arch == 'x64'
        uses: tauri-apps/tauri-action@v0
        with:
          tagName: ${{ startsWith(github.ref, 'refs/tags/') && github.ref_name || format('dev-{0}', github.sha) }}
          releaseName: ${{ startsWith(github.ref, 'refs/tags/') && format('OpenFrp CPL v{0}', github.ref_name) || format('Development Build ({0})', github.sha) }}
          releaseBody: ${{ startsWith(github.ref, 'refs/tags/') && '请查看 [CHANGELOG.md](https://github.com/${{ github.repository }}/blob/main/CHANGELOG.md) 了解更新内容。' || format('开发构建 - 提交信息：{0}', github.event.head_commit.message) }}
          releaseDraft: ${{ startsWith(github.ref, 'refs/tags/') }}
          prerelease: ${{ !startsWith(github.ref, 'refs/tags/') }}
          includeRelease: true
          includeUpdaterJson: true

      - name: Upload x64 artifacts
        if: matrix.arch == 'x64'
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.platform }}-${{ matrix.arch }}-artifacts
          path: |
            src-tauri/target/**/release/bundle/*/update.json
          if-no-files-found: warn

      - name: Build the app (WINDOWS ARM64)
        if: matrix.arch == 'arm64' && matrix.platform == 'windows-latest'
        uses: tauri-apps/tauri-action@v0
        with:
          tagName: ${{ startsWith(github.ref, 'refs/tags/') && github.ref_name || format('dev-{0}', github.sha) }}
          releaseName: ${{ startsWith(github.ref, 'refs/tags/') && format('OpenFrp CPL v{0}', github.ref_name) || format('Development Build ({0})', github.sha) }}
          releaseBody: ${{ startsWith(github.ref, 'refs/tags/') && '请查看 [CHANGELOG.md](https://github.com/${{ github.repository }}/blob/main/CHANGELOG.md) 了解更新内容。' || format('开发构建 - 提交信息：{0}', github.event.head_commit.message) }}
          releaseDraft: ${{ startsWith(github.ref, 'refs/tags/') }}
          prerelease: ${{ !startsWith(github.ref, 'refs/tags/') }}
          includeRelease: true
          includeUpdaterJson: true
          args: --target aarch64-pc-windows-msvc

      - name: Upload Windows ARM64 artifacts
        if: matrix.arch == 'arm64' && matrix.platform == 'windows-latest'
        uses: actions/upload-artifact@v4
        with:
          name: windows-arm64-artifacts
          path: |
            src-tauri/target/aarch64-pc-windows-msvc/release/bundle/msi/update.json
          if-no-files-found: warn

      - name: Import Apple Certificate
        if: matrix.platform == 'macos-latest'
        run: |
          echo "配置证书环境..."
          
          # 清理任何可能存在的旧keychain
          security delete-keychain build.keychain || true
          
          # 创建新的临时keychain
          security create-keychain -p "${{ secrets.KEYCHAIN_PASSWORD }}" build.keychain
          security list-keychains -d user -s build.keychain login.keychain
          security default-keychain -s build.keychain
          security unlock-keychain -p "${{ secrets.KEYCHAIN_PASSWORD }}" build.keychain
          
          # 设置keychain超时时间，确保在构建过程中不会锁定
          security set-keychain-settings -t 3600 -l build.keychain
    
          echo "导入证书..."
          echo "${{ secrets.CERTIFICATES_P12 }}" | base64 --decode > certificate.p12
          security import certificate.p12 \
            -k build.keychain \
            -P "${{ secrets.CERTIFICATES_P12_PASSWORD }}" \
            -T /usr/bin/codesign \
            -T /usr/bin/security
    
          echo "设置keychain分区列表..."
          security set-key-partition-list \
            -S apple-tool:,apple:,codesign: \
            -s -k "${{ secrets.KEYCHAIN_PASSWORD }}" \
            build.keychain
    
          echo "验证证书导入情况..."
          security find-identity -v build.keychain

      - name: Build the app (macOS universal)
        if: matrix.platform == 'macos-latest' && matrix.arch == 'universal'
        uses: tauri-apps/tauri-action@v0
        env:
          MACOSX_DEPLOYMENT_TARGET: 10.14
        with:
          tagName: ${{ startsWith(github.ref, 'refs/tags/') && github.ref_name || format('dev-{0}', github.sha) }}
          releaseName: ${{ startsWith(github.ref, 'refs/tags/') && format('OpenFrp CPL v{0}', github.ref_name) || format('Development Build ({0})', github.sha) }}
          releaseBody: ${{ startsWith(github.ref, 'refs/tags/') && '请查看 [CHANGELOG.md](https://github.com/${{ github.repository }}/blob/main/CHANGELOG.md) 了解更新内容。' || format('开发构建 - 提交信息：{0}', github.event.head_commit.message) }}
          releaseDraft: ${{ startsWith(github.ref, 'refs/tags/') }}
          prerelease: ${{ !startsWith(github.ref, 'refs/tags/') }}
          includeRelease: true
          includeUpdaterJson: true
          args: --target universal-apple-darwin

      - name: Upload macOS artifacts
        if: matrix.platform == 'macos-latest' && matrix.arch == 'universal'
        uses: actions/upload-artifact@v4
        with:
          name: macos-universal-artifacts
          path: |
            src-tauri/target/universal-apple-darwin/release/bundle/macos/update.json
          if-no-files-found: warn

      - name: Re-sign with Entitlements (macOS only)
        if: matrix.platform == 'macos-latest'
        run: |
          # 应用路径
          APP_PATH="/Users/runner/work/OpenFrp-CrossPlatformLauncher/OpenFrp-CrossPlatformLauncher/src-tauri/target/universal-apple-darwin/release/bundle/macos/OpenFrp-CrossPlatformLauncher.app"
          ENTITLEMENTS_PATH="$(pwd)/macos.entitlements"
          
          echo "检查entitlements文件："
          cat "${ENTITLEMENTS_PATH}"
          
          echo "重新签名应用及其所有组件..."
          
          # 签名所有内部框架和库
          find "${APP_PATH}/Contents" -type f -name "*.dylib" -o -name "*.so" | while read -r file; do
            codesign --force --timestamp --options runtime --entitlements "${ENTITLEMENTS_PATH}" --sign "Developer ID Application: Enjie Ye (W6D36R8RMG)" "$file"
          done
          
          find "${APP_PATH}/Contents/Frameworks" -type d -name "*.framework" | while read -r framework; do
            codesign --force --timestamp --options runtime --entitlements "${ENTITLEMENTS_PATH}" --sign "Developer ID Application: Enjie Ye (W6D36R8RMG)" "$framework"
          done
          
          # 最后签名主应用
          codesign --force --timestamp --options runtime --entitlements "${ENTITLEMENTS_PATH}" --sign "Developer ID Application: Enjie Ye (W6D36R8RMG)" "${APP_PATH}"
          
          # 验证签名
          codesign -dvv "${APP_PATH}"

      - name: Create and Sign DMG (macOS only)
        if: matrix.platform == 'macos-latest'
        id: create_dmg
        run: |
          echo "创建DMG包..."
          # 设置路径变量
          APP_PATH="/Users/runner/work/OpenFrp-CrossPlatformLauncher/OpenFrp-CrossPlatformLauncher/src-tauri/target/universal-apple-darwin/release/bundle/macos/OpenFrp-CrossPlatformLauncher.app"
          DMG_PATH="/Users/runner/work/OpenFrp-CrossPlatformLauncher/OpenFrp-CrossPlatformLauncher/src-tauri/target/OpenFrp-CrossPlatformLauncher.dmg"
          TEMP_DMG_PATH="/Users/runner/work/OpenFrp-CrossPlatformLauncher/OpenFrp-CrossPlatformLauncher/src-tauri/target/temp.dmg"
          
          # 确保应用已签名
          echo "检查应用签名状态..."
          codesign -dvv "${APP_PATH}" || echo "应用可能未正确签名，但会继续尝试"
          
          # 检查目标路径是否存在
          [ -d "${APP_PATH}" ] || { echo "应用不存在于路径: ${APP_PATH}"; exit 1; }
          
          # 创建临时DMG
          echo "创建临时未签名DMG..."
          hdiutil create -volname "OpenFrp-CPL" -srcfolder "${APP_PATH}" -ov -format UDRW "${TEMP_DMG_PATH}"
          
          # 将临时DMG转换为最终DMG
          echo "转换DMG格式..."
          hdiutil convert "${TEMP_DMG_PATH}" -format UDZO -o "${DMG_PATH}"
          
          # 删除临时DMG
          rm -f "${TEMP_DMG_PATH}"
          
          # 显示证书信息进行调试
          echo "可用证书信息："
          security find-identity -v build.keychain
          
          # 尝试签名DMG
          echo "签名DMG..."
          codesign --force --sign "Developer ID Application: Enjie Ye (W6D36R8RMG)" --keychain build.keychain --timestamp --verbose "${DMG_PATH}" || {
            echo "第一次签名尝试失败，重试使用详细模式..."
            
            # 第二次尝试，更详细的输出
            codesign --force --sign "Developer ID Application: Enjie Ye (W6D36R8RMG)" --keychain build.keychain --timestamp --verbose=4 "${DMG_PATH}" || {
              echo "签名再次失败，但会继续处理..."
            }
          }
          
          echo "检查DMG签名状态..."
          codesign -dvv "${DMG_PATH}" || echo "DMG签名验证失败，但将继续处理"
          
          echo "dmg_path=${DMG_PATH}" >> $GITHUB_OUTPUT

      - name: Notarize DMG (macOS only)
        if: matrix.platform == 'macos-latest'
        run: |
          echo "准备公证DMG文件..."
          if [ ! -f "${{ steps.create_dmg.outputs.dmg_path }}" ]; then
            echo "DMG文件不存在，跳过公证步骤"
            exit 0
          fi
          
          # 检查DMG基本信息
          echo "DMG文件信息："
          ls -la "${{ steps.create_dmg.outputs.dmg_path }}"
          file "${{ steps.create_dmg.outputs.dmg_path }}"
          
          # 尝试公证
          echo "提交公证请求..."
          NOTARIZATION_INFO=$(mktemp)
          
          # 使用xcrun altool作为备选方案
          if ! xcrun notarytool submit "${{ steps.create_dmg.outputs.dmg_path }}" \
            --apple-id "${{ secrets.APPLE_ID }}" \
            --password "${{ secrets.APPLE_SPECIFIC_PASSWORD }}" \
            --team-id "${{ secrets.TEAM_ID }}" \
            --wait --timeout 1200 > "${NOTARIZATION_INFO}" 2>&1; then
            
            echo "notarytool失败，尝试使用altool..."
            xcrun altool --notarize-app \
              --primary-bundle-id "org.openfrp.cpl" \
              --username "${{ secrets.APPLE_ID }}" \
              --password "${{ secrets.APPLE_SPECIFIC_PASSWORD }}" \
              --team-id "${{ secrets.TEAM_ID }}" \
              --file "${{ steps.create_dmg.outputs.dmg_path }}" > "${NOTARIZATION_INFO}" 2>&1 || {
                echo "公证失败，但将继续构建"
                exit 0
              }
          fi
          
          echo "公证输出："
          cat "${NOTARIZATION_INFO}"
          
          # 即使公证失败也继续处理
          echo "尝试添加公证戳章..."
          xcrun stapler staple "${{ steps.create_dmg.outputs.dmg_path }}" || echo "添加公证戳章失败，但将继续构建"
          
          # 验证结果
          echo "验证签名和公证状态..."
          xcrun stapler validate "${{ steps.create_dmg.outputs.dmg_path }}" || echo "验证失败，但将继续构建"
          spctl --assess --type open --context context:primary-signature -v "${{ steps.create_dmg.outputs.dmg_path }}" || echo "spctl验证失败，但将继续构建"

      - name: Upload signed DMG to Release (macOS only)
        if: matrix.platform == 'macos-latest' && startsWith(github.ref, 'refs/tags/')
        run: |
          if [ -f "${{ steps.create_dmg.outputs.dmg_path }}" ]; then
            echo "DMG文件存在，准备上传"
            # 创建一个备用DMG副本，即使没有签名也可以使用
            cp "${{ steps.create_dmg.outputs.dmg_path }}" "${{ steps.create_dmg.outputs.dmg_path }}.unsigned.dmg" || true
            
            # 尝试上传原始DMG
            gh release upload ${{ github.ref_name }} "${{ steps.create_dmg.outputs.dmg_path }}" --clobber || echo "上传原始DMG失败"
            
            # 上传备用DMG
            gh release upload ${{ github.ref_name }} "${{ steps.create_dmg.outputs.dmg_path }}.unsigned.dmg" --clobber || echo "上传备用DMG失败"
          else
            echo "DMG文件不存在，跳过上传"
          fi
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  process-updates:
    needs: release
    if: startsWith(github.ref, 'refs/tags/')
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts

      - name: Display artifact structure
        run: find artifacts -type f | sort

      - name: Process update files
        run: |
          mkdir -p updates
          # 复制所有update.json文件到updates目录，并根据平台进行重命名
          find artifacts -name "update.json" -exec sh -c '
            platform=$(echo "{}" | grep -o "windows\|macos\|ubuntu\|linux")
            arch=$(echo "{}" | grep -o "x64\|arm64\|universal")
            if [ -n "$platform" ] && [ -n "$arch" ]; then
              cp {} "updates/${platform}-${arch}-update.json"
              echo "复制 {} 到 updates/${platform}-${arch}-update.json"
            else
              # 尝试从路径推断平台
              if echo "{}" | grep -q "aarch64-pc-windows-msvc"; then
                cp {} "updates/windows-arm64-update.json"
                echo "复制 {} 到 updates/windows-arm64-update.json"
              elif echo "{}" | grep -q "universal-apple-darwin"; then
                cp {} "updates/macos-universal-update.json"
                echo "复制 {} 到 updates/macos-universal-update.json"
              elif echo "{}" | grep -q "msi"; then
                cp {} "updates/windows-x64-update.json" 
                echo "复制 {} 到 updates/windows-x64-update.json"
              elif echo "{}" | grep -q "appimage\|deb"; then
                cp {} "updates/linux-x64-update.json"
                echo "复制 {} 到 updates/linux-x64-update.json"
              else
                # 如果无法识别，使用默认名称
                filename=$(basename $(dirname {}))
                cp {} "updates/unknown-${filename}-update.json"
                echo "复制 {} 到 updates/unknown-${filename}-update.json"
              fi
            fi
          ' \;
          
          # 列出所有已收集的更新文件
          echo "已收集的更新文件:"
          ls -la updates/
          
          # 创建合并脚本
          cat > merge-updates.js << 'EOF'
          const fs = require('fs');
          const path = require('path');
          
          // 获取所有更新文件
          const updateFiles = fs.readdirSync('updates')
            .filter(file => file.endsWith('.json'))
            .map(file => path.join('updates', file));
          
          console.log('找到以下更新文件:', updateFiles);
          
          // 合并更新数据
          const mergedUpdates = { 
            version: '',
            notes: '',
            pub_date: new Date().toISOString(),
            platforms: {} 
          };
          
          // 读取package.json获取版本信息(如果存在)
          try {
            if (fs.existsSync('package.json')) {
              const pkg = JSON.parse(fs.readFileSync('package.json', 'utf8'));
              if (pkg.version) {
                mergedUpdates.version = pkg.version;
                console.log(`从package.json获取版本: ${pkg.version}`);
              }
            }
          } catch (err) {
            console.error('读取package.json失败:', err);
          }
          
          updateFiles.forEach(file => {
            try {
              console.log(`处理文件: ${file}`);
              const content = fs.readFileSync(file, 'utf8');
              const updateData = JSON.parse(content);
              
              // 获取平台信息
              let platform = '';
              if (file.includes('windows')) platform = 'windows-x86_64';
              else if (file.includes('windows-arm64')) platform = 'windows-aarch64';
              else if (file.includes('macos')) platform = 'darwin-universal';
              else if (file.includes('linux') || file.includes('ubuntu')) platform = 'linux-x86_64';
              
              console.log(`文件 ${file} 对应平台: ${platform}`);
              
              // 合并平台数据
              if (updateData.platforms && Object.keys(updateData.platforms).length > 0) {
                // 如果文件中有平台数据，直接合并
                Object.keys(updateData.platforms).forEach(p => {
                  mergedUpdates.platforms[p] = updateData.platforms[p];
                  console.log(`从文件合并平台数据: ${p}`);
                });
              } else if (platform && updateData.url) {
                // 如果我们能推断平台，并且有url，创建平台条目
                mergedUpdates.platforms[platform] = {
                  signature: updateData.signature || '',
                  url: updateData.url
                };
                console.log(`为平台 ${platform} 创建条目，URL: ${updateData.url}`);
              }
              
              // 确保版本信息一致
              if (updateData.version && !mergedUpdates.version) {
                mergedUpdates.version = updateData.version;
                console.log(`设置版本: ${updateData.version}`);
              }
              
              // 合并发布说明
              if (updateData.notes && !mergedUpdates.notes) {
                mergedUpdates.notes = updateData.notes;
              }
            } catch (err) {
              console.error(`处理 ${file} 时出错:`, err);
            }
          });
          
          // 写入合并结果
          fs.writeFileSync('merged-update.json', JSON.stringify(mergedUpdates, null, 2));
          console.log('合并完成，生成了: merged-update.json');
          console.log('合并结果:');
          console.log(JSON.stringify(mergedUpdates, null, 2));
          EOF
          
          # 运行合并脚本
          node merge-updates.js
          
          # 复制生成的更新文件为标准更新名称
          cp merged-update.json update.json

      - name: Upload merged update file
        uses: softprops/action-gh-release@v1
        with:
          files: |
            merged-update.json
            update.json
          tag_name: ${{ github.ref_name }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          
      - name: Update latest release
        if: startsWith(github.ref, 'refs/tags/')
        run: |
          # 创建latest.json指向最新版本
          echo "{\"version\":\"${{ github.ref_name }}\",\"url\":\"https://github.com/${{ github.repository }}/releases/download/${{ github.ref_name }}/update.json\"}" > latest.json
          cat latest.json
      
      - name: Upload latest.json
        if: startsWith(github.ref, 'refs/tags/')
        uses: softprops/action-gh-release@v1
        with:
          files: latest.json
          tag_name: latest
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
