name: Release
on:
  push:
    tags: [ 'v*' ]
  workflow_dispatch:

permissions:
  contents: write
  packages: write
  deployments: write

jobs:
  release:
    strategy:
      fail-fast: false
      matrix:
        platform: [macos-latest, ubuntu-latest, windows-latest]
        arch: [x64, arm64]
        exclude:
          - platform: macos-latest
            arch: x64
          - platform: macos-latest
            arch: arm64
          - platform: ubuntu-latest
            arch: arm64
        include:
          - platform: macos-latest
            arch: universal
    runs-on: ${{ matrix.platform }}
    env:
      TAURI_PRIVATE_KEY: ${{ secrets.TAURI_PRIVATE_KEY }}
      TAURI_KEY_PASSWORD: ${{ secrets.TAURI_KEY_PASSWORD }}
      GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install Rust (Stable)
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.platform == 'windows-latest' && matrix.arch == 'arm64' && 'aarch64-pc-windows-msvc' || matrix.platform == 'macos-latest' && matrix.arch == 'universal' && 'aarch64-apple-darwin x86_64-apple-darwin' || '' }}

      - name: Rust Cache
        uses: Swatinem/rust-cache@v2
        with:
          shared-key: "tauri-build-${{ matrix.platform }}-${{ matrix.arch || 'x64' }}"

      - name: Install Dependencies (ubuntu only)
        if: matrix.platform == 'ubuntu-latest'
        run: |
          sudo apt-get update
          sudo apt-get install -y libgtk-3-dev libwebkit2gtk-4.1-dev libappindicator3-dev librsvg2-dev patchelf libssl-dev

      - name: Install frontend dependencies
        run: npm install

      - name: Install macOS targets
        if: matrix.platform == 'macos-latest'
        run: |
          rustup target add x86_64-apple-darwin aarch64-apple-darwin

      - name: Setup Windows ARM64 environment
        if: matrix.platform == 'windows-latest' && matrix.arch == 'arm64'
        run: |
          echo "RUSTFLAGS=-C target-feature=+crt-static" >> $GITHUB_ENV

      - name: Build the app (Standard x64)
        if: matrix.arch == 'x64'
        uses: tauri-apps/tauri-action@v0
        with:
          tagName: ${{ startsWith(github.ref, 'refs/tags/') && github.ref_name || format('dev-{0}', github.sha) }}
          releaseName: ${{ startsWith(github.ref, 'refs/tags/') && format('OpenFrp CPL v{0}', github.ref_name) || format('Development Build ({0})', github.sha) }}
          releaseBody: ${{ startsWith(github.ref, 'refs/tags/') && '请查看 [CHANGELOG.md](https://github.com/${{ github.repository }}/blob/main/CHANGELOG.md) 了解更新内容。' || format('开发构建 - 提交信息：{0}', github.event.head_commit.message) }}
          releaseDraft: ${{ startsWith(github.ref, 'refs/tags/') }}
          prerelease: ${{ !startsWith(github.ref, 'refs/tags/') }}
          includeRelease: true
          includeUpdaterJson: true

      - name: Upload x64 artifacts
        if: matrix.arch == 'x64'
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.platform }}-${{ matrix.arch }}-artifacts
          path: |
            src-tauri/gen/*/metadata.json
            src-tauri/target/**/release/*.msi
            src-tauri/target/**/release/*.exe
            src-tauri/target/**/release/bundle/deb/*.deb
            src-tauri/target/**/release/bundle/appimage/*.AppImage
          if-no-files-found: warn

      - name: Build the app (WINDOWS ARM64)
        if: matrix.arch == 'arm64' && matrix.platform == 'windows-latest'
        uses: tauri-apps/tauri-action@v0
        with:
          tagName: ${{ startsWith(github.ref, 'refs/tags/') && github.ref_name || format('dev-{0}', github.sha) }}
          releaseName: ${{ startsWith(github.ref, 'refs/tags/') && format('OpenFrp CPL v{0}', github.ref_name) || format('Development Build ({0})', github.sha) }}
          releaseBody: ${{ startsWith(github.ref, 'refs/tags/') && '请查看 [CHANGELOG.md](https://github.com/${{ github.repository }}/blob/main/CHANGELOG.md) 了解更新内容。' || format('开发构建 - 提交信息：{0}', github.event.head_commit.message) }}
          releaseDraft: ${{ startsWith(github.ref, 'refs/tags/') }}
          prerelease: ${{ !startsWith(github.ref, 'refs/tags/') }}
          includeRelease: true
          includeUpdaterJson: true
          args: --target aarch64-pc-windows-msvc

      - name: Upload Windows ARM64 artifacts
        if: matrix.arch == 'arm64' && matrix.platform == 'windows-latest'
        uses: actions/upload-artifact@v4
        with:
          name: windows-arm64-artifacts
          path: |
            src-tauri/gen/aarch64-pc-windows-msvc/metadata.json
            src-tauri/target/aarch64-pc-windows-msvc/release/*.msi
            src-tauri/target/aarch64-pc-windows-msvc/release/*.exe
          if-no-files-found: warn

      - name: Import Apple Certificate
        if: matrix.platform == 'macos-latest'
        run: |
          echo "配置证书环境..."
          
          # 清理任何可能存在的旧keychain
          security delete-keychain build.keychain || true
          
          # 创建新的临时keychain
          security create-keychain -p "${{ secrets.KEYCHAIN_PASSWORD }}" build.keychain
          security list-keychains -d user -s build.keychain login.keychain
          security default-keychain -s build.keychain
          security unlock-keychain -p "${{ secrets.KEYCHAIN_PASSWORD }}" build.keychain
          
          # 设置keychain超时时间，确保在构建过程中不会锁定
          security set-keychain-settings -t 3600 -l build.keychain
    
          echo "导入证书..."
          echo "${{ secrets.CERTIFICATES_P12 }}" | base64 --decode > certificate.p12
          security import certificate.p12 \
            -k build.keychain \
            -P "${{ secrets.CERTIFICATES_P12_PASSWORD }}" \
            -T /usr/bin/codesign \
            -T /usr/bin/security
    
          echo "设置keychain分区列表..."
          security set-key-partition-list \
            -S apple-tool:,apple:,codesign: \
            -s -k "${{ secrets.KEYCHAIN_PASSWORD }}" \
            build.keychain
    
          echo "验证证书导入情况..."
          security find-identity -v build.keychain

      - name: Build the app (macOS universal)
        if: matrix.platform == 'macos-latest' && matrix.arch == 'universal'
        uses: tauri-apps/tauri-action@v0
        env:
          MACOSX_DEPLOYMENT_TARGET: 10.14
        with:
          tagName: ${{ startsWith(github.ref, 'refs/tags/') && github.ref_name || format('dev-{0}', github.sha) }}
          releaseName: ${{ startsWith(github.ref, 'refs/tags/') && format('OpenFrp CPL v{0}', github.ref_name) || format('Development Build ({0})', github.sha) }}
          releaseBody: ${{ startsWith(github.ref, 'refs/tags/') && '请查看 [CHANGELOG.md](https://github.com/${{ github.repository }}/blob/main/CHANGELOG.md) 了解更新内容。' || format('开发构建 - 提交信息：{0}', github.event.head_commit.message) }}
          releaseDraft: ${{ startsWith(github.ref, 'refs/tags/') }}
          prerelease: ${{ !startsWith(github.ref, 'refs/tags/') }}
          includeRelease: true
          includeUpdaterJson: true
          args: --target universal-apple-darwin

      - name: Upload macOS artifacts
        if: matrix.platform == 'macos-latest' && matrix.arch == 'universal'
        uses: actions/upload-artifact@v4
        with:
          name: macos-universal-artifacts
          path: |
            src-tauri/gen/universal-apple-darwin/metadata.json
            src-tauri/target/universal-apple-darwin/release/bundle/*.dmg
            src-tauri/target/universal-apple-darwin/release/bundle/*.app.tar.gz
          if-no-files-found: warn

      - name: Re-sign with Entitlements (macOS only)
        if: matrix.platform == 'macos-latest'
        run: |
          # 应用路径
          APP_PATH="/Users/runner/work/OpenFrp-CrossPlatformLauncher/OpenFrp-CrossPlatformLauncher/src-tauri/target/universal-apple-darwin/release/bundle/macos/OpenFrp-CrossPlatformLauncher.app"
          ENTITLEMENTS_PATH="$(pwd)/macos.entitlements"
          
          echo "检查entitlements文件："
          cat "${ENTITLEMENTS_PATH}"
          
          echo "重新签名应用及其所有组件..."
          
          # 签名所有内部框架和库
          find "${APP_PATH}/Contents" -type f -name "*.dylib" -o -name "*.so" | while read -r file; do
            codesign --force --timestamp --options runtime --entitlements "${ENTITLEMENTS_PATH}" --sign "Developer ID Application: Enjie Ye (W6D36R8RMG)" "$file"
          done
          
          find "${APP_PATH}/Contents/Frameworks" -type d -name "*.framework" | while read -r framework; do
            codesign --force --timestamp --options runtime --entitlements "${ENTITLEMENTS_PATH}" --sign "Developer ID Application: Enjie Ye (W6D36R8RMG)" "$framework"
          done
          
          # 最后签名主应用
          codesign --force --timestamp --options runtime --entitlements "${ENTITLEMENTS_PATH}" --sign "Developer ID Application: Enjie Ye (W6D36R8RMG)" "${APP_PATH}"
          
          # 验证签名
          codesign -dvv "${APP_PATH}"

      - name: Create and Sign DMG (macOS only)
        if: matrix.platform == 'macos-latest'
        id: create_dmg
        run: |
          echo "创建DMG包..."
          # 设置路径变量
          APP_PATH="/Users/runner/work/OpenFrp-CrossPlatformLauncher/OpenFrp-CrossPlatformLauncher/src-tauri/target/universal-apple-darwin/release/bundle/macos/OpenFrp-CrossPlatformLauncher.app"
          DMG_PATH="/Users/runner/work/OpenFrp-CrossPlatformLauncher/OpenFrp-CrossPlatformLauncher/src-tauri/target/OpenFrp-CrossPlatformLauncher.dmg"
          TEMP_DMG_PATH="/Users/runner/work/OpenFrp-CrossPlatformLauncher/OpenFrp-CrossPlatformLauncher/src-tauri/target/temp.dmg"
          
          # 确保应用已签名
          echo "检查应用签名状态..."
          codesign -dvv "${APP_PATH}" || echo "应用可能未正确签名，但会继续尝试"
          
          # 检查目标路径是否存在
          [ -d "${APP_PATH}" ] || { echo "应用不存在于路径: ${APP_PATH}"; exit 1; }
          
          # 创建临时DMG
          echo "创建临时未签名DMG..."
          hdiutil create -volname "OpenFrp-CPL" -srcfolder "${APP_PATH}" -ov -format UDRW "${TEMP_DMG_PATH}"
          
          # 将临时DMG转换为最终DMG
          echo "转换DMG格式..."
          hdiutil convert "${TEMP_DMG_PATH}" -format UDZO -o "${DMG_PATH}"
          
          # 删除临时DMG
          rm -f "${TEMP_DMG_PATH}"
          
          # 显示证书信息进行调试
          echo "可用证书信息："
          security find-identity -v build.keychain
          
          # 尝试签名DMG
          echo "签名DMG..."
          codesign --force --sign "Developer ID Application: Enjie Ye (W6D36R8RMG)" --keychain build.keychain --timestamp --verbose "${DMG_PATH}" || {
            echo "第一次签名尝试失败，重试使用详细模式..."
            
            # 第二次尝试，更详细的输出
            codesign --force --sign "Developer ID Application: Enjie Ye (W6D36R8RMG)" --keychain build.keychain --timestamp --verbose=4 "${DMG_PATH}" || {
              echo "签名再次失败，但会继续处理..."
            }
          }
          
          echo "检查DMG签名状态..."
          codesign -dvv "${DMG_PATH}" || echo "DMG签名验证失败，但将继续处理"
          
          echo "dmg_path=${DMG_PATH}" >> $GITHUB_OUTPUT

      - name: Notarize DMG (macOS only)
        if: matrix.platform == 'macos-latest'
        run: |
          echo "准备公证DMG文件..."
          if [ ! -f "${{ steps.create_dmg.outputs.dmg_path }}" ]; then
            echo "DMG文件不存在，跳过公证步骤"
            exit 0
          fi
          
          # 检查DMG基本信息
          echo "DMG文件信息："
          ls -la "${{ steps.create_dmg.outputs.dmg_path }}"
          file "${{ steps.create_dmg.outputs.dmg_path }}"
          
          # 尝试公证
          echo "提交公证请求..."
          NOTARIZATION_INFO=$(mktemp)
          
          # 使用xcrun altool作为备选方案
          if ! xcrun notarytool submit "${{ steps.create_dmg.outputs.dmg_path }}" \
            --apple-id "${{ secrets.APPLE_ID }}" \
            --password "${{ secrets.APPLE_SPECIFIC_PASSWORD }}" \
            --team-id "${{ secrets.TEAM_ID }}" \
            --wait --timeout 1200 > "${NOTARIZATION_INFO}" 2>&1; then
            
            echo "notarytool失败，尝试使用altool..."
            xcrun altool --notarize-app \
              --primary-bundle-id "org.openfrp.cpl" \
              --username "${{ secrets.APPLE_ID }}" \
              --password "${{ secrets.APPLE_SPECIFIC_PASSWORD }}" \
              --team-id "${{ secrets.TEAM_ID }}" \
              --file "${{ steps.create_dmg.outputs.dmg_path }}" > "${NOTARIZATION_INFO}" 2>&1 || {
                echo "公证失败，但将继续构建"
                exit 0
              }
          fi
          
          echo "公证输出："
          cat "${NOTARIZATION_INFO}"
          
          # 即使公证失败也继续处理
          echo "尝试添加公证戳章..."
          xcrun stapler staple "${{ steps.create_dmg.outputs.dmg_path }}" || echo "添加公证戳章失败，但将继续构建"
          
          # 验证结果
          echo "验证签名和公证状态..."
          xcrun stapler validate "${{ steps.create_dmg.outputs.dmg_path }}" || echo "验证失败，但将继续构建"
          spctl --assess --type open --context context:primary-signature -v "${{ steps.create_dmg.outputs.dmg_path }}" || echo "spctl验证失败，但将继续构建"

      - name: Upload signed DMG to Release (macOS only)
        if: matrix.platform == 'macos-latest' && startsWith(github.ref, 'refs/tags/')
        run: |
          if [ -f "${{ steps.create_dmg.outputs.dmg_path }}" ]; then
            echo "DMG文件存在，准备上传"
            # 创建一个备用DMG副本，即使没有签名也可以使用
            cp "${{ steps.create_dmg.outputs.dmg_path }}" "${{ steps.create_dmg.outputs.dmg_path }}.unsigned.dmg" || true
            
            # 尝试上传原始DMG
            gh release upload ${{ github.ref_name }} "${{ steps.create_dmg.outputs.dmg_path }}" --clobber || echo "上传原始DMG失败"
            
            # 上传备用DMG
            gh release upload ${{ github.ref_name }} "${{ steps.create_dmg.outputs.dmg_path }}.unsigned.dmg" --clobber || echo "上传备用DMG失败"
          else
            echo "DMG文件不存在，跳过上传"
          fi
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Upload binary files to release
        if: startsWith(github.ref, 'refs/tags/')
        run: |
          # 上传所有二进制文件到release
          find artifacts -type f -name "*.exe" -o -name "*.msi" -o -name "*.AppImage" -o -name "*.deb" -o -name "*.dmg" | while read -r file; do
            echo "上传 $file 到 GitHub Release"
            # 提取文件名，避免路径问题
            filename=$(basename "$file")
            cp "$file" "./$filename"
            gh release upload ${{ github.ref_name }} "./$filename" --clobber
          done
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  process-updates:
    needs: release
    if: startsWith(github.ref, 'refs/tags/')
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts

      - name: Display artifact structure
        run: find artifacts -type f | sort

      - name: Process metadata files
        run: |
          mkdir -p updates
          
          # 创建一个新的处理脚本
          cat > process-artifacts.cjs << 'EOF'
          const fs = require('fs');
          const path = require('path');
          
          // 获取所有二进制文件
          const binaryFiles = [];
          const artifactsDir = 'artifacts';
          
          // 递归查找所有二进制文件
          function findBinaryFiles(dir) {
            if (!fs.existsSync(dir)) return;
            
            const files = fs.readdirSync(dir);
            for (const file of files) {
              const filePath = path.join(dir, file);
              const stat = fs.statSync(filePath);
              if (stat.isDirectory()) {
                findBinaryFiles(filePath);
              } else if (
                file.endsWith('.exe') || 
                file.endsWith('.msi') || 
                file.endsWith('.AppImage') || 
                file.endsWith('.deb') || 
                file.endsWith('.dmg')
              ) {
                console.log(`找到二进制文件: ${filePath}`);
                binaryFiles.push(filePath);
              }
            }
          }
          
          // 在artifacts目录中查找二进制文件
          if (fs.existsSync(artifactsDir)) {
            findBinaryFiles(artifactsDir);
          } else {
            console.error('找不到artifacts目录');
            process.exit(1);
          }
          
          // 如果没有找到二进制文件，退出
          if (binaryFiles.length === 0) {
            console.error('未找到任何二进制文件');
            process.exit(1);
          }
          
          // 从package.json获取版本信息
          let appInfo = { 
            version: process.env.GITHUB_REF_NAME ? process.env.GITHUB_REF_NAME.replace(/^v/, '') : '0.0.0',
            name: 'OpenFrp-CrossPlatformLauncher'
          };
          try {
            if (fs.existsSync('package.json')) {
              const pkg = JSON.parse(fs.readFileSync('package.json', 'utf8'));
              if (pkg.version) appInfo.version = pkg.version;
              if (pkg.name) appInfo.name = pkg.name;
              console.log(`从package.json获取版本: ${appInfo.version}`);
            }
          } catch (err) {
            console.error('读取package.json失败:', err);
          }
          
          // 准备更新数据
          const updateData = {
            version: appInfo.version,
            notes: '请查看CHANGELOG.md了解更新内容。',
            pub_date: new Date().toISOString(),
            platforms: {}
          };
          
          // 识别平台
          function detectPlatform(filePath) {
            const isWindows = filePath.includes('windows') || filePath.endsWith('.exe') || filePath.endsWith('.msi');
            const isMacOS = filePath.includes('macos') || filePath.includes('darwin') || filePath.endsWith('.dmg');
            const isLinux = filePath.includes('linux') || filePath.includes('ubuntu') || filePath.endsWith('.AppImage') || filePath.endsWith('.deb');
            
            const isArm64 = filePath.includes('arm64') || filePath.includes('aarch64');
            const isUniversal = filePath.includes('universal');
            
            if (isWindows) {
              return isArm64 ? 'windows-aarch64' : 'windows-x86_64';
            } else if (isMacOS) {
              if (isUniversal) return 'darwin-universal';
              return isArm64 ? 'darwin-aarch64' : 'darwin-x86_64';
            } else if (isLinux) {
              return 'linux-x86_64';
            }
            
            return null;
          }
          
          // 处理二进制文件
          for (const file of binaryFiles) {
            try {
              console.log(`处理文件: ${file}`);
              
              // 检测平台
              const platform = detectPlatform(file);
              if (!platform) {
                console.warn(`无法识别平台: ${file}`);
                continue;
              }
              
              console.log(`文件 ${file} 对应平台: ${platform}`);
              
              // 获取文件名
              const fileName = path.basename(file);
              
              // 创建基础URL
              const baseUrl = `https://github.com/${process.env.GITHUB_REPOSITORY}/releases/download/${process.env.GITHUB_REF_NAME}`;
              
              // 为平台创建条目
              updateData.platforms[platform] = {
                url: `${baseUrl}/${fileName}`,
                signature: '' // Tauri 2会自动验证签名
              };
              
              console.log(`为平台 ${platform} 创建条目:`, updateData.platforms[platform]);
            } catch (err) {
              console.error(`处理 ${file} 时出错:`, err);
            }
          }
          
          // 写入更新文件
          fs.writeFileSync('update.json', JSON.stringify(updateData, null, 2));
          fs.writeFileSync('merged-update.json', JSON.stringify(updateData, null, 2));
          
          console.log('生成的更新文件:');
          console.log(JSON.stringify(updateData, null, 2));
          EOF
          
          # 运行处理脚本
          node process-artifacts.cjs

      - name: Upload merged update file
        uses: softprops/action-gh-release@v1
        with:
          files: |
            merged-update.json
            update.json
          tag_name: ${{ github.ref_name }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          
      - name: Update latest release
        if: startsWith(github.ref, 'refs/tags/')
        run: |
          # 创建latest.json指向最新版本
          echo "{\"version\":\"${{ github.ref_name }}\",\"url\":\"https://github.com/${{ github.repository }}/releases/download/${{ github.ref_name }}/update.json\"}" > latest.json
          cat latest.json
      
      - name: Upload latest.json
        if: startsWith(github.ref, 'refs/tags/')
        uses: softprops/action-gh-release@v1
        with:
          files: latest.json
          tag_name: latest
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
